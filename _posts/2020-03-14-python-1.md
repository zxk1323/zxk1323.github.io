---
title: 'Python | 列表与元组'
date: 2020-03-14
permalink: /posts/2020/03/Python-1/
tags:
  - Python
---

#### 列表和元组

#### 基础

列表和元组，都是**一个可以放置任意数据类型的有序集合**。

列表和元组的区别

- **列表是动态的**，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。 
- **而元组是静态的**，长度大小固定，无法增加删减或者改变（immutable）

列表和元组可以随意嵌套，两者也可以通过list（）和tuple（）函数相互转换.

列表和元组常用的内置函数:

- count(item) 表示统计列表 / 元组中 item 出现的次数。 
- index(item) 表示返回列表 / 元组中 item 第一次出现的索引。 
- list.reverse() 和 list.sort() 分别表示原地倒转列表和排序（注意，元组没有内置的这两个函数)。 

- reversed() 和 sorted() 同样表示对列表 / 元组进行倒转和排序，但是会返回一个倒转后或者排好序的新的列表 / 元组。

#### 存储方式

```python
l = [1,2,3]
l.__sizeof__() #64
tup = (1,2,3)
tup.__sizeof__() #48
```

我们放置了相同的元素，但是元组的存储空间，却比列表要少 16 字节。这是为什么呢？

事实上，由于列表是动态的，所以它需要存储指针，来指向对应的元素（上述例子中，对于 int 型，8 字节）。另外，由于列表可变，所以需要额外存储已经分配的长度大小（8 字 节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间。

```python
l = []
l.__sizeof__() # 空列表的存储空间为40字节
l.append(1)
l.__sizeof__()
72 # 加入了元素1之后列表为其分配了可以存储 4 个元素的空间(72 - 40)/8 = 4
l.append(2)
l.__sizeof__()
72 # 由于之前分配了空间，所以加入2，列表空间不变
l.append(3)
l.__sizeof__()
72 #同上
l.append(4)
l.__sizeof__()
72 #同上
l.append(5)
l.__sizeof__()
104 # 加入元素5之后，列表的空间不足，所以又额外分配了可以存储4个元素的空间
```

上面的例子，大概描述了列表空间分配的过程。我们可以看到，为了减小每次增加 / 删减 操作时空间分配的开销，Python 每次分配空间时都会额外多分配一些，这样的机制 （over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)。

但是对于元组，情况就不同了。元组长度大小固定，元素不可变，所以存储空间固定。

#### 性能比较

元组要比列表更加轻量级一些，所以总体上来说，元组的性能速度要略优于列表。

增加、删减或者改变元素，列表显然更优。原因对于元组，你必须得通过新建一个元组来完成。

#### 使用场景

1. 如果存储的数据和数量不变，比如你有一个函数，需要返回的是一个地点的经纬度，然后直接传给前端渲染，那么肯定选用元组更合适。

```python
def get_location():
    ...
    return (longitude, latitude)
```

1. 如果存储的数据或数量是可变的，比如社交平台上的一个日志功能，是统计一个用户在一周之内看了哪些用户的帖子，那么则用列表更合适。

```python
viewer_owner_id_list = [] # 里面的每个元素记录了这个viewer一周内看过的所有owner的id
records = querDB(viewer_id) # 索引数据库拿到某个Viewer一周内的日志
for record in records:
    viewer_owner_id_list.append(record.id)
```